Весь исходный код лежит в репозитории https://github.com/ivan-reshetnyak/test-wargaming

Задание №1
bool isEven1( int value ) {
  return value % 2 == 0;
}

bool isEven2( int value ) {
  return !(value & 1);
}

Алгоритм 2 в теории может работать быстрее (на очень древних машинах без арифметического сопроцессора и без оптимизации компилятора), но ценой этого является его пониженная читаемость. Учитывая возможности автоматической оптимизации современных компиляторов, гораздо предпочтительнее пользоваться простым и понятным алгоритмом 1.

Задание №2
См. https://github.com/ivan-reshetnyak/test-wargaming/tree/master/circular-buffer
Приведены две реализации циклического буфера - на массиве и на односвязном списке.
Обе реализации имеют время чтения/записи O(1).
Однако реализация на списке способна расширять буфер с сохранением существующих данных за O(m), где m - количество новых записей, в то время на массиве подобное расширение займет O(n+m), где n - изначальный размер буфера.
Заметим также, что реализация на списке чаще использует выделение памяти - как при инициализации, так и при изменении размера.
Наконец, при больших объемах обрабатываемых данных в загруженной системе реализация на массиве может чаще сталкиваться с проблемой нехватки памяти, так как проще найти много маленьких свободных кусков памяти, чем один большой.

Задание №3
См. https://github.com/ivan-reshetnyak/test-wargaming/tree/master/sort
Приведена реализация "quick sort" - имеет среднее время работы O(n*log(n)) и очень низкую числовую константу, что чаще всего делает его самым быстрым алгоритмом сортировки (несмотря на то, что его максимальное время работы - O(n^2), достигаемое в специфических случаях).
